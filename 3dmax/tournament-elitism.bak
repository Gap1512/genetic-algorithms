#lang racket

(require "shared.rkt")

(provide genetic-algorithm)

(define %RANDOM (λ () (/ (random 1000000) 1000000)))

(define (genetic-algorithm #:function (fn GA-FUNCTION)
                           #:selection (selection 'roulette)
                           #:tournament-k (tournament-k 4)
                           #:resolution (resolution 10)
                           #:elitism (elitism 2)
                           #:range-min (range-min 0)
                           #:range-max (range-max 512)
                           #:pc (pc 0.6)
                           #:pm (pm 0.01)
                           #:last-generation (last-generation 70)
                           #:number-of-individuals (number-of-individuals 50))
  (let* ((max-value (expt 2 resolution))
         (total-range (- range-max range-min))
         (precision (/ max-value total-range))
         (initial-population (generate-initial-population number-of-individuals range-min max-value precision)))
    (update-population '() 0 initial-population)))

(define (generate-initial-population number-of-individuals range-min max-value precision)
  (let ((initial-population '()))
    (for ([i number-of-individuals])
      (set! initial-population (cons (+ range-min (/ (random max-value) precision)) initial-population)))))

(define (update-population populations actual-generation actual-population)
  (cond
    ((= actual-generation last-generation) populations)
    (t (let ((formated-population (add-fitness actual-population function))
             (new-generation (compose-new-generation formated-population elitism selection tournament-k pc pm)) 
         (update-population (cons formated-population populations)
                            (add1 actual-generation)
                            new-generation))))))

(define (add-fitness population function)
  (map (λ (x) (list x (function x))) population))

(define (compose-new-generation f-population elitism selection tournament-k pc pm)
  (let ((new-generation (select-best elitism f-population))
        (population (case selection
                      (:roulette (add-cumulative-fitness f-population))
                      (:tournament f-population))))
    (for ([i (- (length f-population) elitism)])
      (let*-values ([(p1 p2) (select-parents population selection tournament-k)]
                    [(b1 b2) (binary-parents p1 p2 resolution precision)]
                    [(f1 f2) (crossover p1 p2 pc)]
                    [(m1 m2) (mutation f1 f2 pm)]
                    [(ind1 ind2) (decimal-sons m1 m2)])
        (set! new-generation (cons ind1 (cons ind2 new-generation)))))))

(define (select-best k f-population)
  (subseq (sort f-population > #:key second) k))

(define (subseq list end)
  (subseq-aux '() list end))

(define (subseq-aux result list end)
  (cond
    ((zero? end) result)
    (else (subseq-aux (cons (car list) result) (cdr list) (sub1 end)))))

(define (add-cumulative-fitness f-population)
  (let ((sum (apply + (map second f-population)))
        (acc 0))
    (map (λ (ind)
           (let ((aux acc))
             (set! acc (+ acc (/ (second ind) sum)))
             (list (first ind)
                   aux
                   acc)))
         f-population)))

(define (select-parents population selection tournament-k)
  (case selection
    (:roulette (let* ((rnd1 (%RANDOM))
                      (rnd2 (%RANDOM))
                      (p1 (findf (λ (x) (search-proc x rnd1)) population))
                      (p2 (findf (λ (x) (search-proc x rnd2)) population)))
                 (values (first p1) (first p2))))
    (:tournament
     (let ((p1 (car (sort (select-random tournament-k population) > #:key second)))
           (p2 (car (sort (select-random tournament-k population) > #:key second))))
       (values (first p1) (first p2))))))

(define (search-proc x rnd)
  (and (< (second x) rnd) (> (third x) rnd)))

(define (binary-parents p1 p2 resolution precision)
  (values (decimal->binary (ceiling (* p1 precision)))
          (decimal->binary (ceiling (* p2 precision)))))

(define (decimal->binary decimal resolution)
  (decimal->binary-aux decimal "" resolution resolution))

(define (decimal->binary-aux decimal result i resolution)
  (cond
    ((zero? i) result)
    ((zero? decimal) (decimal->binary-aux decimal (string-append "0" result)
                                          (sub1 i)
                                          resolution))
    (else (decimal->binary-aux (quotient decimal 2)
                               (string-append (number->string (inexact->exact (remainder decimal 2))) result)
                               (sub1 i)
                               resolution))))

(define (crossover p1 p2 pc)
  (if (